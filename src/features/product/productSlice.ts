import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
// import { RootState, AppThunk } from "../../app/store";

/**
 * Better not to infer from return type of fetch call.
 */
export interface ProductRtn {
  id: number;
  name: string;
  description: string;
  picture: string;
  type: {
    id: number;
    name: string;
  };
  categories: {
    id: number;
    name: string;
  }[];
  implementationEffortText: unknown;
  investmentEffort: string;
  trl: {
    id: number;
    name: string;
  };
  video: string;
  user: {
    id: number;
    email: string;
    firstName: string;
    lastName: string;
    sex: number;
    profilePicture: string;
    position: string;
  };
  company: {
    name: string;
    logo: string;
    address: {
      country: {
        name: string;
      };
      city: {
        name: string;
      };
      street: string;
      house: string;
      zipCode: string;
      longitude: string;
      latitude: string;
    };
  };
  businessModels: {
    id: number;
    name: string;
  }[];
}

export interface ProductState {
  value: ProductRtn;
  status: "idle" | "loading" | "failed";
}

const initialState: ProductState = {
  value: {
    id: -1,
    name: "",
    description: "",
    picture: "",
    type: {
      id: -1,
      name: "",
    },
    categories: [
      {
        id: -1,
        name: "",
      },
    ],
    implementationEffortText: null,
    investmentEffort: "",
    trl: {
      id: -1,
      name: "",
    },
    video: "",
    user: {
      id: -1,
      email: "",
      firstName: "",
      lastName: "",
      sex: -1,
      profilePicture: "",
      position: "",
    },
    company: {
      name: "",
      logo: "",
      address: {
        country: {
          name: "",
        },
        city: {
          name: "",
        },
        street: "",
        house: "",
        zipCode: "",
        longitude: "",
        latitude: "",
      },
    },
    businessModels: [
      {
        id: -1,
        name: "",
      },
    ],
  },
  status: "idle",
};

const BASE_URL = "https://api-test.innoloft.com/" as const;

export const incrementAsync = createAsyncThunk(
  "product/fetchProduct",
  async () => {
    const response = await fetch(`${BASE_URL}/product/6781/`);
    const data = response.json();
    // The value we return becomes the `fulfilled` action payload
    return data;
  }
);

export const productSlice = createSlice({
  name: "counter",
  initialState,
  reducers: {
    increment: (state) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      //   state.value += 1;
    },
    decrement: (state) => {
      //   state.value -= 1;
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementByAmount: (state, action: PayloadAction<ProductRtn>) => {
      state.value = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(incrementAsync.pending, (state) => {
        state.status = "loading";
      })
      .addCase(incrementAsync.fulfilled, (state, action) => {
        state.status = "idle";
        state.value = action.payload;
      })
      .addCase(incrementAsync.rejected, (state) => {
        state.status = "failed";
      });
  },
});

export const { increment, decrement, incrementByAmount } = productSlice.actions;

export default productSlice.reducer;
